package langchaingo

import (
	"context"
	"fmt"
	"github.com/google/uuid"
	"github.com/tmc/langchaingo/llms"
	"github.com/tmc/langchaingo/llms/openai"
)

// Define the interface for LangChain operations
type LangChainClient interface {
	StartSession(ctx context.Context) (string, error)
	SendMessage(ctx context.Context, sessionID string, message string) (string, error)
	EndSession(ctx context.Context, sessionID string) error
}

// Client structure to implement the LangChainClient interface
type Client struct {
	llm      llms.Model
	sessions map[string][]llms.MessageContent
}

// NewClient creates a new instance of Client
func NewClient() (*Client, error) {
	opts := []openai.Option{
		openai.WithToken("your-openai-api-key"), // Customize your token retrieval
		openai.WithModel("text-davinci-003"),    // Example model, specify as needed
	}

	llm, err := openai.New(opts...)
	if err != nil {
		return nil, err
	}

	return &Client{
		llm:      llm,
		sessions: make(map[string][]llms.MessageContent),
	}, nil
}

// StartSession initializes a new chat session and returns a session ID
func (c *Client) StartSession(ctx context.Context) (string, error) {
	sessionID := generateSessionID() // Implement this function to generate unique session IDs
	c.sessions[sessionID] = []llms.MessageContent{}
	return sessionID, nil
}

// SendMessage handles sending a message to the LLM and returning the response
func (c *Client) SendMessage(ctx context.Context, sessionID string, message string) (string, error) {
	messages, exists := c.sessions[sessionID]
	if !exists {
		return "", fmt.Errorf("session not found")
	}

	// Create a MessageContent object with the user's message
	userMessage := llms.MessageContent{
		Role:  llms.ChatMessageTypeHuman,
		Parts: []llms.ContentPart{llms.TextPart(message)},
	}

	// Append the new message to the session's message history
	messages = append(messages, userMessage)
	c.sessions[sessionID] = messages

	// Call GenerateContent to get a response from the LLM
	response, err := c.llm.GenerateContent(ctx, messages)
	if err != nil {
		return "", err
	}

	if len(response.Choices) == 0 {
		return "", fmt.Errorf("no response generated by the model")
	}

	return response.Choices[0].Content, nil
}

// EndSession clears the session data
func (c *Client) EndSession(ctx context.Context, sessionID string) error {
	if _, exists := c.sessions[sessionID]; !exists {
		return fmt.Errorf("session not found")
	}
	delete(c.sessions, sessionID)
	return nil
}

// Utility function to generate unique session IDs
func generateSessionID() string {
	// Implement a method to generate unique session IDs, such as UUIDs
	return uuid.NewString() // This requires importing "github.com/google/uuid"
}
